<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kaito-kidd.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="你好，我是 Kaito。 在软件开发领域，「异地多活」是分布式系统架构设计的一座高峰，很多人经常听过它，但很少人理解其中的原理。 异地多活到底是什么？为什么需要异地多活？它到底解决了什么问题？究竟是怎么解决的？ 这些疑问，想必是每个程序看到异地多活这个名词时，都想要搞明白的问题。 有幸，我曾经深度参与过一个中等互联网公司，建设异地多活系统的设计与实施过程。所以今天，我就来和你聊一聊异地多活背后的的">
<meta property="og:type" content="article">
<meta property="og:title" content="搞懂异地多活，看这篇就够了">
<meta property="og:url" content="http://kaito-kidd.com/2021/10/15/what-is-the-multi-site-high-availability-design/index.html">
<meta property="og:site_name" content="Kaito&#39;s Blog">
<meta property="og:description" content="你好，我是 Kaito。 在软件开发领域，「异地多活」是分布式系统架构设计的一座高峰，很多人经常听过它，但很少人理解其中的原理。 异地多活到底是什么？为什么需要异地多活？它到底解决了什么问题？究竟是怎么解决的？ 这些疑问，想必是每个程序看到异地多活这个名词时，都想要搞明白的问题。 有幸，我曾经深度参与过一个中等互联网公司，建设异地多活系统的设计与实施过程。所以今天，我就来和你聊一聊异地多活背后的的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382026.png">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382032.png">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342401650504.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382044.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382051.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382060.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382067.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382073.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382080.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382087.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382098.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342338343496.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382121.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342338343503.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342338343511.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342338343518.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382158.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382165.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382172.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382180.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382187.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382194.jpg">
<meta property="og:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382203.jpg">
<meta property="article:published_time" content="2021-10-15T10:43:32.000Z">
<meta property="article:modified_time" content="2023-09-26T17:05:17.562Z">
<meta property="article:author" content="Kaito">
<meta property="article:tag" content="高可用">
<meta property="article:tag" content="架构">
<meta property="article:tag" content="异地多活">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382026.png">

<link rel="canonical" href="http://kaito-kidd.com/2021/10/15/what-is-the-multi-site-high-availability-design/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>搞懂异地多活，看这篇就够了 | Kaito's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ac0da3d41844c2dea65fd550d38fa4c1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Kaito's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">致力成为一枚silver bullet.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kaito-kidd.com/2021/10/15/what-is-the-multi-site-high-availability-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/15584.jpg">
      <meta itemprop="name" content="Kaito">
      <meta itemprop="description" content="坐标北京，9年+工作经验，做过UGC高并发后端服务研发，目前从事基础架构&云原生方向，涉及领域包括：Redis、中间件、基础架构、异地多活、K8s、云原生。追求技术，关注互联网动态。工具控、电影迷！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaito's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          搞懂异地多活，看这篇就够了
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-15 10:43:32" itemprop="dateCreated datePublished" datetime="2021-10-15T10:43:32+00:00">2021-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">架构设计</span></a>
                </span>
            </span>

          
            <span id="/2021/10/15/what-is-the-multi-site-high-availability-design/" class="post-meta-item leancloud_visitors" data-flag-title="搞懂异地多活，看这篇就够了" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/10/15/what-is-the-multi-site-high-availability-design/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/10/15/what-is-the-multi-site-high-availability-design/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>你好，我是 Kaito。</p>
<p>在软件开发领域，「异地多活」是分布式系统架构设计的一座高峰，很多人经常听过它，但很少人理解其中的原理。</p>
<p><strong>异地多活到底是什么？为什么需要异地多活？它到底解决了什么问题？究竟是怎么解决的？</strong></p>
<p>这些疑问，想必是每个程序看到异地多活这个名词时，都想要搞明白的问题。</p>
<p>有幸，我曾经深度参与过一个中等互联网公司，建设异地多活系统的设计与实施过程。所以今天，我就来和你聊一聊异地多活背后的的实现原理。</p>
<p>认真读完这篇文章，我相信你会对异地多活架构，有更加深刻的理解。</p>
<p><strong>这篇文章干货很多，希望你可以耐心读完。</strong></p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382026.png" alt=""></p>
<a id="more"></a>

<h1 id="01-系统可用性"><a href="#01-系统可用性" class="headerlink" title="01 系统可用性"></a>01 系统可用性</h1><p>要想理解异地多活，我们需要从架构设计的原则说起。</p>
<p>现如今，我们开发一个软件系统，对其要求越来越高，如果你了解一些「架构设计」的要求，就知道一个好的软件架构应该遵循以下 3 个原则：</p>
<ol>
<li>高性能</li>
<li>高可用</li>
<li>易扩展</li>
</ol>
<p>其中，高性能意味着系统拥有更大流量的处理能力，更低的响应延迟。例如 1 秒可处理 10W 并发请求，接口响应时间 5 ms 等等。</p>
<p>易扩展表示系统在迭代新功能时，能以最小的代价去扩展，系统遇到流量压力时，可以在不改动代码的前提下，去扩容系统。</p>
<p>而「高可用」这个概念，看起来很抽象，怎么理解它呢？通常用 2 个指标来衡量：</p>
<ul>
<li><strong>平均故障间隔 MTBF</strong>（Mean Time Between Failure）：表示两次故障的间隔时间，也就是系统「正常运行」的平均时间，这个时间越长，说明系统稳定性越高</li>
<li><strong>故障恢复时间 MTTR</strong>（Mean Time To Repair）：表示系统发生故障后「恢复的时间」，这个值越小，故障对用户的影响越小</li>
</ul>
<p>可用性与这两者的关系：</p>
<blockquote>
<p>可用性（Availability）= MTBF / (MTBF + MTTR) * 100%</p>
</blockquote>
<p>这个公式得出的结果是一个「比例」，通常我们会用「N 个 9」来描述一个系统的可用性。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382032.png" alt=""></p>
<p>从这张图你可以看到，要想达到 4 个 9 以上的可用性，平均每天故障时间必须控制在 10 秒以内。</p>
<p>也就是说，只有故障的时间「越短」，整个系统的可用性才会越高，每提升 1 个 9，都会对系统提出更高的要求。</p>
<p>我们都知道，系统发生故障其实是不可避免的，尤其是规模越大的系统，发生问题的概率也越大。这些故障一般体现在 3 个方面：</p>
<ol>
<li><strong>硬件故障</strong>：CPU、内存、磁盘、网卡、交换机、路由器</li>
<li><strong>软件问题</strong>：代码 Bug、版本迭代</li>
<li><strong>不可抗力</strong>：地震、水灾、火灾、战争</li>
</ol>
<p>这些风险随时都有可能发生。所以，在面对故障时，我们的系统能否以「最快」的速度恢复，就成为了可用性的关键。</p>
<p>可如何做到快速恢复呢？</p>
<p>这篇文章要讲的「异地多活」架构，就是为了解决这个问题，而提出的高效解决方案。</p>
<p>下面，我会从一个最简单的系统出发，带你一步步演化出一个支持「异地多活」的系统架构。</p>
<p>在这个过程中，你会看到一个系统会遇到哪些可用性问题，以及为什么架构要这样演进，从而理解异地多活架构的意义。</p>
<h1 id="02-单机架构"><a href="#02-单机架构" class="headerlink" title="02 单机架构"></a>02 单机架构</h1><p>我们从最简单的开始讲起。</p>
<p>假设你的业务处于起步阶段，体量非常小，那你的架构是这样的：</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342401650504.jpg" alt=""></p>
<p>这个架构模型非常简单，客户端请求进来，业务应用读写数据库，返回结果，非常好理解。</p>
<p>但需要注意的是，这里的数据库是「单机」部署的，所以它有一个致命的缺点：一旦遭遇意外，例如磁盘损坏、操作系统异常、误删数据，那这意味着所有数据就全部「丢失」了，这个损失是巨大的。</p>
<p>如何避免这个问题呢？我们很容易想到一个方案：<strong>备份</strong>。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382044.jpg" alt=""></p>
<p>你可以对数据做备份，把数据库文件「定期」cp 到另一台机器上，这样，即使原机器丢失数据，你依旧可以通过备份把数据「恢复」回来，以此保证数据安全。</p>
<p>这个方案实施起来虽然比较简单，但存在 2 个问题：</p>
<ol>
<li><strong>恢复需要时间</strong>：业务需先停机，再恢复数据，停机时间取决于恢复的速度，恢复期间服务「不可用」</li>
<li><strong>数据不完整</strong>：因为是定期备份，数据肯定不是「最新」的，数据完整程度取决于备份的周期</li>
</ol>
<p>很明显，你的数据库越大，意味故障恢复时间越久。那按照前面我们提到的「高可用」标准，这个方案可能连 1 个 9 都达不到，远远无法满足我们对可用性的要求。</p>
<p>那有什么更好的方案，既可以快速恢复业务？还能尽可能保证数据完整性呢？</p>
<p>这时你可以采用这个方案：<strong>主从副本</strong>。</p>
<h1 id="03-主从副本"><a href="#03-主从副本" class="headerlink" title="03 主从副本"></a>03 主从副本</h1><p>你可以在另一台机器上，再部署一个数据库实例，让这个新实例成为原实例的「副本」，让两者保持「实时同步」，就像这样：</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382051.jpg" alt=""></p>
<p>我们一般把原实例叫作主库（master），新实例叫作从库（slave）。这个方案的优点在于：</p>
<ul>
<li><strong>数据完整性高</strong>：主从副本实时同步，数据「差异」很小</li>
<li><strong>抗故障能力提升</strong>：主库有任何异常，从库可随时「切换」为主库，继续提供服务</li>
<li><strong>读性能提升</strong>：业务应用可直接读从库，分担主库「压力」读压力</li>
</ul>
<p>这个方案不错，不仅大大提高了数据库的可用性，还提升了系统的读性能。</p>
<p>同样的思路，你的「业务应用」也可以在其它机器部署一份，避免单点。因为业务应用通常是「无状态」的（不像数据库那样存储数据），所以直接部署即可，非常简单。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382060.jpg" alt=""></p>
<p>因为业务应用部署了多个，所以你现在还需要部署一个「接入层」，来做请求的「负载均衡」（一般会使用 nginx 或 LVS），这样当一台机器宕机后，另一台机器也可以「接管」所有流量，持续提供服务。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382067.jpg" alt=""></p>
<p>从这个方案你可以看出，提升可用性的关键思路就是：<strong>冗余</strong>。</p>
<p>没错，担心一个实例故障，那就部署多个实例，担心一个机器宕机，那就部署多台机器。</p>
<p>到这里，你的架构基本已演变成主流方案了，之后开发新的业务应用，都可以按照这种模式去部署。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382073.jpg" alt=""></p>
<p>但这种方案还有什么风险吗？</p>
<h1 id="04-风险不可控"><a href="#04-风险不可控" class="headerlink" title="04 风险不可控"></a>04 风险不可控</h1><p>现在让我们把视角下放，把焦点放到具体的「部署细节」上来。</p>
<p>按照前面的分析，为了避免单点故障，你的应用虽然部署了多台机器，但这些机器的分布情况，我们并没有去深究。</p>
<p>而一个机房有很多服务器，这些服务器通常会分布在一个个「机柜」上，如果你使用的这些机器，刚好在一个机柜，还是存在风险。</p>
<p>如果恰好连接这个机柜的交换机 / 路由器发生故障，那么你的应用依旧有「不可用」的风险。</p>
<blockquote>
<p>虽然交换机 / 路由器也做了路线冗余，但不能保证一定不出问题。</p>
</blockquote>
<p>部署在一个机柜有风险，那把这些机器打散，分散到不同机柜上，是不是就没问题了？</p>
<p>这样确实会大大降低出问题的概率。但我们依旧不能掉以轻心，因为无论怎么分散，它们总归还是在一个相同的环境下：<strong>机房</strong>。</p>
<p>那继续追问，机房会不会发生故障呢？</p>
<p>一般来讲，建设一个机房的要求其实是很高的，地理位置、温湿度控制、备用电源等等，机房厂商会在各方面做好防护。但即使这样，我们每隔一段时间还会看到这样的新闻：</p>
<ul>
<li>2015 年 5 月 27 日，杭州市某地光纤被挖断，近 3 亿用户长达 5 小时无法访问支付宝</li>
<li>2021 年 7 月 13 日，B 站部分服务器机房发生故障，造成整站持续 3 个小时无法访问</li>
<li>2021 年 10 月 9 日，富途证券服务器机房发生电力闪断故障，造成用户 2 个小时无法登陆、交易</li>
<li>…</li>
</ul>
<p>可见，即使机房级别的防护已经做得足够好，但只要有「概率」出问题，那现实情况就有可能发生。虽然概率很小，但一旦真的发生，影响之大可见一斑。</p>
<p>看到这里你可能会想，机房出现问题的概率也太小了吧，工作了这么多年，也没让我碰上一次，有必要考虑得这么复杂吗？</p>
<p>但你有没有思考这样一个问题：<strong>不同体量的系统，它们各自关注的重点是什么？</strong></p>
<p>体量很小的系统，它会重点关注「用户」规模、增长，这个阶段获取用户是一切。等用户体量上来了，这个阶段会重点关注「性能」，优化接口响应时间、页面打开速度等等，这个阶段更多是关注用户体验。</p>
<p>等体量再大到一定规模后你会发现，「可用性」就变得尤为重要。像微信、支付宝这种全民级的应用，如果机房发生一次故障，那整个影响范围可以说是非常巨大的。</p>
<p>所以，再小概率的风险，我们在提高系统可用性时，也不能忽视。</p>
<p>分析了风险，再说回我们的架构。那到底该怎么应对机房级别的故障呢？</p>
<p>没错，还是<strong>冗余</strong>。</p>
<h1 id="05-同城灾备"><a href="#05-同城灾备" class="headerlink" title="05 同城灾备"></a>05 同城灾备</h1><p>想要抵御「机房」级别的风险，那应对方案就不能局限在一个机房内了。</p>
<p>现在，你需要做机房级别的冗余方案，也就是说，你需要再搭建一个机房，来部署你的服务。</p>
<p>简单起见，你可以在「同一个城市」再搭建一个机房，原机房我们叫作 A 机房，新机房叫 B 机房，这两个机房的网络用一条「专线」连通。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382080.jpg" alt=""></p>
<p>有了新机房，怎么把它用起来呢？这里还是要优先考虑「数据」风险。</p>
<p>为了避免 A 机房故障导致数据丢失，所以我们需要把数据在 B 机房也存一份。最简单的方案还是和前面提到的一样：<strong>备份</strong>。</p>
<p>A 机房的数据，定时在 B 机房做备份（拷贝数据文件），这样即使整个 A 机房遭到严重的损坏，B 机房的数据不会丢，通过备份可以把数据「恢复」回来，重启服务。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382087.jpg" alt=""></p>
<p>这种方案，我们称之为「<strong>冷备</strong>」。为什么叫冷备呢？因为 B 机房只做备份，不提供实时服务，它是冷的，只会在 A 机房故障时才会启用。</p>
<p>但备份的问题依旧和之前描述的一样：数据不完整、恢复数据期间业务不可用，整个系统的可用性还是无法得到保证。</p>
<p>所以，我们还是需要用「主从副本」的方式，在 B 机房部署 A 机房的数据副本，架构就变成了这样：</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382098.jpg" alt=""></p>
<p>这样，就算整个 A 机房挂掉，我们在 B 机房也有比较「完整」的数据。</p>
<p>数据是保住了，但这时你需要考虑另外一个问题：<strong>如果 A 机房真挂掉了，要想保证服务不中断，你还需要在 B 机房「紧急」做这些事情</strong>：</p>
<ol>
<li>B 机房所有从库提升为主库</li>
<li>在 B 机房部署应用，启动服务</li>
<li>部署接入层，配置转发规则</li>
<li>DNS 指向 B 机房接入层，接入流量，业务恢复</li>
</ol>
<p>看到了么？A 机房故障后，B 机房需要做这么多工作，你的业务才能完全「恢复」过来。</p>
<p>你看，整个过程需要人为介入，且需花费大量时间来操作，恢复之前整个服务还是不可用的，这个方案还是不太爽，如果能做到故障后立即「切换」，那就好了。</p>
<p>因此，要想缩短业务恢复的时间，你必须把这些工作在 B 机房「提前」做好，也就是说，你需要在 B 机房提前部署好接入层、业务应用，等待随时切换。架构就变成了这样：</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342338343496.jpg" alt=""></p>
<p>这样的话，A 机房整个挂掉，我们只需要做 2 件事即可：</p>
<ol>
<li>B 机房所有从库提升为主库</li>
<li>DNS 指向 B 机房接入层，接入流量，业务恢复</li>
</ol>
<p>这样一来，恢复速度快了很多。</p>
<p>到这里你会发现，B 机房从最开始的「空空如也」，演变到现在，几乎是「镜像」了一份 A 机房的所有东西，从最上层的接入层，到中间的业务应用，到最下层的存储。两个机房唯一的区别是，<strong>A 机房的存储都是主库，而 B 机房都是从库</strong>。</p>
<p>这种方案，我们把它叫做「<strong>热备</strong>」。</p>
<p>热的意思是指，B 机房处于「待命」状态，A 故障后 B 可以随时「接管」流量，继续提供服务。热备相比于冷备最大的优点是：<strong>随时可切换</strong>。</p>
<p>无论是冷备还是热备，因为它们都处于「备用」状态，所以我们把这两个方案统称为：<strong>同城灾备</strong>。</p>
<p>同城灾备的最大优势在于，我们再也不用担心「机房」级别的故障了，一个机房发生风险，我们只需把流量切换到另一个机房即可，可用性再次提高，是不是很爽？（后面还有更爽的）</p>
<h1 id="06-同城双活"><a href="#06-同城双活" class="headerlink" title="06 同城双活"></a>06 同城双活</h1><p>我们继续来看这个架构。</p>
<p>虽然我们有了应对机房故障的解决方案，但这里有个问题是我们不能忽视的：<strong>A 机房挂掉，全部流量切到 B 机房，B 机房能否真的如我们所愿，正常提供服务？</strong></p>
<p>这是个值得思考的问题。</p>
<p>这就好比有两支军队 A 和 B，A 军队历经沙场，作战经验丰富，而 B 军队只是后备军，除了有军人的基本素养之外，并没有实战经验，战斗经验基本为 0。</p>
<p>如果 A 军队丧失战斗能力，需要 B 军队立即顶上时，作为指挥官的你，肯定也会担心 B 军队能否真的担此重任吧？</p>
<p>我们的架构也是如此，此时的 B 机房虽然是随时「待命」状态，但 A 机房真的发生故障，我们要把全部流量切到 B 机房，其实是不敢百分百保证它可以「如期」工作的。</p>
<p>你想，我们在一个机房内部署服务，还总是发生各种各样的问题，例如：发布应用的版本不一致、系统资源不足、操作系统参数不一样等等。现在多部署一个机房，这些问题只会增多，不会减少。</p>
<p>另外，从「成本」的角度来看，我们新部署一个机房，需要购买服务器、内存、硬盘、带宽资源，花费成本也是非常高昂的，只让它当一个后备军，未免也太「大材小用」了！</p>
<p>因此，我们需要让 B 机房也接入流量，实时提供服务，这样做的好处，<strong>一是可以实时训练这支后备军，让它达到与 A 机房相同的作战水平，随时可切换，二是 B 机房接入流量后，可以分担 A 机房的流量压力</strong>。这才是把 B 机房资源优势，发挥最大化的最好方案！</p>
<p>那怎么让 B 机房也接入流量呢？很简单，就是把 B 机房的接入层 IP 地址，加入到 DNS 中，这样，B 机房从上层就可以有流量进来了。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382121.jpg" alt=""></p>
<p>但这里有一个问题：别忘了，B 机房的存储，现在可都是 A 机房的「从库」，从库默认可都是「不可写」的，B 机房的写请求打到本机房存储上，肯定会报错，这还是不符合我们预期。怎么办？</p>
<p>这时，你就需要在「业务应用」层做改造了。</p>
<p>你的业务应用在操作数据库时，需要区分「读写分离」（一般用中间件实现），即两个机房的「读」流量，可以读任意机房的存储，但「写」流量，只允许写 A 机房，因为主库在 A 机房。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342338343503.jpg" alt=""></p>
<p>这会涉及到你用的所有存储，例如项目中用到了 MySQL、Redis、MongoDB 等等，操作这些数据库，都需要区分读写请求，所以这块需要一定的业务「改造」成本。</p>
<p>因为 A 机房的存储都是主库，所以我们把 A 机房叫做「主机房」，B 机房叫「从机房」。</p>
<p>两个机房部署在「同城」，物理距离比较近，而且两个机房用「专线」网络连接，虽然跨机房访问的延迟，比单个机房内要大一些，但整体的延迟还是可以接受的。</p>
<p>业务改造完成后，B 机房可以慢慢接入流量，从 10%、30%、50% 逐渐覆盖到 100%，你可以持续观察 B 机房的业务是否存在问题，有问题及时修复，逐渐让 B 机房的工作能力，达到和 A 机房相同水平。</p>
<p>现在，因为 B 机房实时接入了流量，此时如果 A 机房挂了，那我们就可以「大胆」地把 A 的流量，全部切换到 B 机房，完成快速切换！</p>
<p>到这里你可以看到，我们部署的 B 机房，在物理上虽然与 A 有一定距离，但整个系统从「逻辑」上来看，我们是把这两个机房看做一个「整体」来规划的，也就是说，相当于把 2 个机房当作 1 个机房来用。</p>
<p>这种架构方案，比前面的同城灾备更「进了一步」，B 机房实时接入了流量，还能应对随时的故障切换，这种方案我们把它叫做「<strong>同城双活</strong>」。</p>
<p>因为两个机房都能处理业务请求，这对我们系统的内部维护、改造、升级提供了更多的可实施空间（流量随时切换），现在，整个系统的弹性也变大了，是不是更爽了？</p>
<p>那这种架构有什么问题呢？</p>
<h1 id="07-两地三中心"><a href="#07-两地三中心" class="headerlink" title="07 两地三中心"></a>07 两地三中心</h1><p>还是回到风险上来说。</p>
<p>虽然我们把 2 个机房当做一个整体来规划，但这 2 个机房在物理层面上，还是处于「一个城市」内，如果是整个城市发生自然灾害，例如地震、水灾（河南水灾刚过去不久），那 2 个机房依旧存在「全局覆没」的风险。</p>
<p>真是防不胜防啊？怎么办？没办法，继续冗余。</p>
<p>但这次冗余机房，就不能部署在同一个城市了，你需要把它放到距离更远的地方，部署在「异地」。</p>
<blockquote>
<p>通常建议两个机房的距离要在 1000 公里以上，这样才能应对城市级别的灾难。</p>
</blockquote>
<p>假设之前的 A、B 机房在北京，那这次新部署的 C 机房可以放在上海。</p>
<p>按照前面的思路，把 C 机房用起来，最简单粗暴的方案还就是做「冷备」，即定时把 A、B 机房的数据，在 C 机房做备份，防止数据丢失。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342338343511.jpg" alt=""></p>
<p>这种方案，就是我们经常听到的「<strong>两地三中心</strong>」。</p>
<p><strong>两地是指 2 个城市，三中心是指有 3 个机房，其中 2 个机房在同一个城市，并且同时提供服务，第 3 个机房部署在异地，只做数据灾备。</strong></p>
<p>这种架构方案，通常用在银行、金融、政企相关的项目中。它的问题还是前面所说的，启用灾备机房需要时间，而且启用后的服务，不确定能否如期工作。</p>
<p>所以，要想真正的抵御城市级别的故障，越来越多的互联网公司，开始实施「<strong>异地双活</strong>」。</p>
<h1 id="08-伪异地双活"><a href="#08-伪异地双活" class="headerlink" title="08 伪异地双活"></a>08 伪异地双活</h1><p>这里，我们还是分析 2 个机房的架构情况。我们不再把 A、B 机房部署在同一个城市，而是分开部署，例如 A 机房放在北京，B 机房放在上海。</p>
<p>前面我们讲了同城双活，那异地双活是不是直接「照搬」同城双活的模式去部署就可以了呢？</p>
<p>事情没你想的那么简单。</p>
<p>如果还是按照同城双活的架构来部署，那异地双活的架构就是这样的：</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342338343518.jpg" alt=""></p>
<p>注意看，两个机房的网络是通过「跨城专线」连通的。</p>
<p>此时两个机房都接入流量，那上海机房的请求，可能要去读写北京机房的存储，这里存在一个很大的问题：<strong>网络延迟</strong>。</p>
<p>因为两个机房距离较远，受到物理距离的限制，现在，两地之间的网络延迟就变成了「<strong>不可忽视</strong>」的因素了。</p>
<p>北京到上海的距离大约 1300 公里，即使架设一条高速的「网络专线」，光纤以光速传输，一个来回也需要近 10ms 的延迟。</p>
<p>况且，网络线路之间还会经历各种路由器、交换机等网络设备，实际延迟可能会达到 30ms ~ 100ms，如果网络发生抖动，延迟甚至会达到 1 秒。</p>
<blockquote>
<p>不止是延迟，远距离的网络专线质量，是远远达不到机房内网络质量的，专线网络经常会发生延迟、丢包、甚至中断的情况。总之，不能过度信任和依赖「跨城专线」。</p>
</blockquote>
<p>你可能会问，这点延迟对业务影响很大吗？影响非常大！</p>
<p>试想，一个客户端请求打到上海机房，上海机房要去读写北京机房的存储，一次跨机房访问延迟就达到了 30ms，这大致是机房内网网络（0.5 ms）访问速度的 60 倍（30ms / 0.5ms），一次请求慢 60 倍，来回往返就要慢 100 倍以上。</p>
<p>而我们在 App 打开一个页面，可能会访问后端几十个 API，每次都跨机房访问，整个页面的响应延迟有可能就达到了<strong>秒级</strong>，这个性能简直惨不忍睹，难以接受。</p>
<p>看到了么，虽然我们只是简单的把机房部署在了「异地」，但「同城双活」的架构模型，在这里就不适用了，还是按照这种方式部署，这是「伪异地双活」！</p>
<p>那如何做到真正的异地双活呢？</p>
<h1 id="09-真正的异地双活"><a href="#09-真正的异地双活" class="headerlink" title="09 真正的异地双活"></a>09 真正的异地双活</h1><p>既然「跨机房」调用延迟是不容忽视的因素，那我们只能尽量避免跨机房「调用」，规避这个延迟问题。</p>
<p>也就是说，上海机房的应用，不能再「跨机房」去读写北京机房的存储，只允许读写上海本地的存储，实现「就近访问」，这样才能避免延迟问题。</p>
<p>还是之前提到的问题：上海机房存储都是从库，不允许写入啊，除非我们只允许上海机房接入「读流量」，不接收「写流量」，否则无法满足不再跨机房的要求。</p>
<p>很显然，只让上海机房接收读流量的方案不现实，因为很少有项目是只有读流量，没有写流量的。所以这种方案还是不行，这怎么办？</p>
<p>此时，你就必须在「<strong>存储层</strong>」做改造了。</p>
<p>要想上海机房读写本机房的存储，那上海机房的存储不能再是北京机房的从库，而是也要变为「主库」。</p>
<p>你没看错，两个机房的存储必须都是「<strong>主库</strong>」，而且两个机房的数据还要「<strong>互相同步</strong>」数据，即客户端无论写哪一个机房，都能把这条数据同步到另一个机房。</p>
<p>因为只有两个机房都拥有「全量数据」，才能支持任意切换机房，持续提供服务。</p>
<p>怎么实现这种「双主」架构呢？它们之间如何互相同步数据？</p>
<p>如果你对 MySQL 有所了解，MySQL 本身就提供了双主架构，它支持双向复制数据，但平时用的并不多。而且 Redis、MongoDB 等数据库并没有提供这个功能，所以，你必须开发对应的「数据同步中间件」来实现双向同步的功能。</p>
<p>此外，除了数据库这种有状态的软件之外，你的项目通常还会使用到消息队列，例如 RabbitMQ、Kafka，这些也是有状态的服务，所以它们也需要开发双向同步的中间件，支持任意机房写入数据，同步至另一个机房。</p>
<p>看到了么，这一下子复杂度就上来了，单单针对每个数据库、队列开发同步中间件，就需要投入很大精力了。</p>
<blockquote>
<p>业界也开源出了很多数据同步中间件，例如阿里的 Canal、RedisShake、MongoShake，可分别在两个机房同步 MySQL、Redis、MongoDB 数据。</p>
<p>很多有能力的公司，也会采用自研同步中间件的方式来做，例如饿了么、携程、美团都开发了自己的同步中间件。</p>
<p>我也有幸参与设计开发了 MySQL、Redis/Codis、MongoDB 的同步中间件，有时间写一篇文章详细聊聊实现细节，欢迎持续关注。:)</p>
</blockquote>
<p>现在，整个架构就变成了这样：</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382158.jpg" alt=""></p>
<p>注意看，两个机房的存储层都互相同步数据的。有了数据同步中间件，就可以达到这样的效果：</p>
<ul>
<li>北京机房写入 X = 1</li>
<li>上海机房写入 Y = 2</li>
<li>数据通过中间件双向同步</li>
<li>北京、上海机房都有 X = 1、Y = 2 的数据</li>
</ul>
<p>这里我们用中间件双向同步数据，就不用再担心专线问题，专线出问题，我们的中间件可以自动重试，直到成功，达到数据最终一致。</p>
<p>但这里还会遇到一个问题，两个机房都可以写，操作的不是同一条数据那还好，如果修改的是同一条的数据，发生冲突怎么办？</p>
<ul>
<li>用户短时间内发了 2 个修改请求，都是修改同一条数据</li>
<li>一个请求落在北京机房，修改 X = 1（还未同步到上海机房）</li>
<li>另一个请求落在上海机房，修改 X = 2（还未同步到北京机房）</li>
<li>两个机房以哪个为准？</li>
</ul>
<p>也就是说，在很短的时间内，同一个用户修改同一条数据，两个机房无法确认谁先谁后，数据发生「冲突」。</p>
<p>这是一个很严重的问题，系统发生故障并不可怕，可怕的是数据发生「错误」，因为修正数据的成本太高了。我们一定要避免这种情况的发生。解决这个问题，有 2 个方案。</p>
<p><strong>第一个方案</strong>，数据同步中间件要有自动「合并」数据、解决「冲突」的能力。</p>
<p>这个方案实现起来比较复杂，要想合并数据，就必须要区分出「先后」顺序。我们很容易想到的方案，就是以「时间」为标尺，以「后到达」的请求为准。</p>
<p>但这种方案需要两个机房的「时钟」严格保持一致才行，否则很容易出现问题。例如：</p>
<ul>
<li>第 1 个请求落到北京机房，北京机房时钟是 10:01，修改 X = 1</li>
<li>第 2 个请求落到上海机房，上海机房时钟是 10:00，修改 X = 2</li>
</ul>
<p>因为北京机房的时间「更晚」，那最终结果就会是 X = 1。但这里其实应该以第 2 个请求为准，X = 2 才对。</p>
<p>可见，完全「依赖」时钟的冲突解决方案，不太严谨。</p>
<p>所以，通常会采用第二种方案，从「源头」就避免数据冲突的发生。</p>
<h1 id="10-如何实施异地双活"><a href="#10-如何实施异地双活" class="headerlink" title="10 如何实施异地双活"></a>10 如何实施异地双活</h1><p>既然自动合并数据的方案实现成本高，那我们就要想，能否从源头就「避免」数据冲突呢？</p>
<p>这个思路非常棒！</p>
<p>从源头避免数据冲突的思路是：<strong>在最上层接入流量时，就不要让冲突的情况发生</strong>。</p>
<p>具体来讲就是，要在最上层就把用户「区分」开，部分用户请求固定打到北京机房，其它用户请求固定打到上海 机房，进入某个机房的用户请求，之后的所有业务操作，都在这一个机房内完成，从根源上避免「跨机房」。</p>
<p>所以这时，你需要在接入层之上，再部署一个「路由层」（通常部署在云服务器上），自己可以配置路由规则，把用户「分流」到不同的机房内。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382165.jpg" alt=""></p>
<p>但这个路由规则，具体怎么定呢？有很多种实现方式，最常见的我总结了 3 类：</p>
<ol>
<li>按业务类型分片</li>
<li>直接哈希分片</li>
<li>按地理位置分片</li>
</ol>
<p><strong>1、按业务类型分片</strong></p>
<p>这种方案是指，按应用的「业务类型」来划分。</p>
<p>举例：假设我们一共有 4 个应用，北京和上海机房都部署这些应用。但应用 1、2 只在北京机房接入流量，在上海机房只是热备。应用 3、4 只在上海机房接入流量，在北京机房是热备。</p>
<p>这样一来，应用 1、2 的所有业务请求，只读写北京机房存储，应用 3、4 的所有请求，只会读写上海机房存储。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382172.jpg" alt=""></p>
<p>这样按业务类型分片，也可以避免同一个用户修改同一条数据。</p>
<blockquote>
<p>这里按业务类型在不同机房接入流量，还需要考虑多个应用之间的依赖关系，要尽可能的把完成「相关」业务的应用部署在同一个机房，避免跨机房调用。</p>
<p>例如，订单、支付服务有依赖关系，会产生互相调用，那这 2 个服务在 A 机房接入流量。社区、发帖服务有依赖关系，那这 2 个服务在 B 机房接入流量。</p>
</blockquote>
<p><strong>2、直接哈希分片</strong></p>
<p>这种方案就是，最上层的路由层，会根据用户 ID 计算「哈希」取模，然后从路由表中找到对应的机房，之后把请求转发到指定机房内。</p>
<p>举例：一共 200 个用户，根据用户 ID 计算哈希值，然后根据路由规则，把用户 1 - 100 路由到北京机房，101 - 200 用户路由到上海机房，这样，就避免了同一个用户修改同一条数据的情况发生。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382180.jpg" alt=""></p>
<p><strong>3、按地理位置分片</strong></p>
<p>这种方案，非常适合与地理位置密切相关的业务，例如打车、外卖服务就非常适合这种方案。</p>
<p>拿外卖服务举例，你要点外卖肯定是「就近」点餐，整个业务范围相关的有商家、用户、骑手，它们都是在相同的地理位置内的。</p>
<p>针对这种特征，就可以在最上层，按用户的「地理位置」来做分片，分散到不同的机房。</p>
<p>举例：北京、河北地区的用户点餐，请求只会打到北京机房，而上海、浙江地区的用户，请求则只会打到上海机房。这样的分片规则，也能避免数据冲突。</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382187.jpg" alt=""></p>
<blockquote>
<p>提醒：这 3 种常见的分片规则，第一次看不太好理解，建议配合图多理解几遍。搞懂这 3 个分片规则，你才能真正明白怎么做异地多活。</p>
</blockquote>
<p>总之，分片的核心思路在于，<strong>让同一个用户的相关请求，只在一个机房内完成所有业务「闭环」，不再出现「跨机房」访问</strong>。</p>
<p>阿里在实施这种方案时，给它起了个名字，叫做「<strong>单元化</strong>」。</p>
<blockquote>
<p>当然，最上层的路由层把用户分片后，理论来说同一个用户只会落在同一个机房内，但不排除程序 Bug 导致用户会在两个机房「漂移」。</p>
<p>安全起见，每个机房在写存储时，还需要有一套机制，能够检测「数据归属」，应用层操作存储时，需要通过中间件来做「兜底」，避免不该写本机房的情况发生。（篇幅限制，这里不展开讲，理解思路即可）</p>
</blockquote>
<p>现在，两个机房就可以都接收「读写」流量（做好分片的请求），底层存储保持「双向」同步，两个机房都拥有全量数据，当任意机房故障时，另一个机房就可以「接管」全部流量，实现快速切换，简直不要太爽。</p>
<p>不仅如此，因为机房部署在异地，我们还可以更细化地「优化」路由规则，让用户访问就近的机房，这样整个系统的性能也会大大提升。</p>
<blockquote>
<p>这里还有一种情况，是无法做数据分片的：<strong>全局数据</strong>。例如系统配置、商品库存这类需要强一致的数据，这类服务依旧只能采用写主机房，读从机房的方案，不做双活。</p>
<p>双活的重点，是要优先保证「核心」业务先实现双活，并不是「全部」业务实现双活。</p>
</blockquote>
<p>至此，我们才算实现了真正的「<strong>异地双活</strong>」！</p>
<blockquote>
<p>到这里你可以看出，完成这样一套架构，需要投入的成本是巨大的。</p>
<p>路由规则、路由转发、数据同步中间件、数据校验兜底策略，不仅需要开发强大的中间件，同时还要业务配合改造（业务边界划分、依赖拆分）等一些列工作，没有足够的人力物力，这套架构很难实施。</p>
</blockquote>
<h1 id="11-异地多活"><a href="#11-异地多活" class="headerlink" title="11 异地多活"></a>11 异地多活</h1><p>理解了异地双活，那「异地多活」顾名思义，就是在异地双活的基础上，部署多个机房即可。架构变成了这样：</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382194.jpg" alt=""></p>
<p>这些服务按照「单元化」的部署方式，可以让每个机房部署在任意地区，随时扩展新机房，你只需要在最上层定义好分片规则就好了。</p>
<p>但这里还有一个小问题，随着扩展的机房越来越多，当一个机房写入数据后，需要同步的机房也越来越多，这个实现复杂度会比较高。</p>
<p>所以业界又把这一架构又做了进一步优化，把「网状」架构升级为「星状」：</p>
<p><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/10/16342320382203.jpg" alt=""></p>
<p>这种方案必须设立一个「中心机房」，任意机房写入数据后，都只同步到中心机房，再由中心机房同步至其它机房。</p>
<p>这样做的好处是，一个机房写入数据，只需要同步数据到中心机房即可，不需要再关心一共部署了多少个机房，实现复杂度大大「简化」。</p>
<p>但与此同时，这个中心机房的「稳定性」要求会比较高。不过也还好，即使中心机房发生故障，我们也可以把任意一个机房，提升为中心机房，继续按照之前的架构提供服务。</p>
<p>至此，我们的系统彻底实现了「<strong>异地多活</strong>」！</p>
<p>多活的优势在于，<strong>可以任意扩展机房「就近」部署。任意机房发生故障，可以完成快速「切换」</strong>，大大提高了系统的可用性。</p>
<p>同时，我们也再也不用担心系统规模的增长，因为这套架构具有极强的「<strong>扩展能力</strong>」。</p>
<p>怎么样？我们从一个最简单的应用，一路优化下来，到最终的架构方案，有没有帮你彻底理解异地多活呢？</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，总结一下这篇文章的重点。</p>
<p>1、一个好的软件架构，应该遵循高性能、高可用、易扩展 3 大原则，其中「高可用」在系统规模变得越来越大时，变得尤为重要</p>
<p>2、系统发生故障并不可怕，能以「最快」的速度恢复，才是高可用追求的目标，异地多活是实现高可用的有效手段</p>
<p>3、提升高可用的核心是「冗余」，备份、主从副本、同城灾备、同城双活、两地三中心、异地双活，异地多活都是在做冗余</p>
<p>4、同城灾备分为「冷备」和「热备」，冷备只备份数据，不提供服务，热备实时同步数据，并做好随时切换的准备</p>
<p>5、同城双活比灾备的优势在于，两个机房都可以接入「读写」流量，提高可用性的同时，还提升了系统性能。虽然物理上是两个机房，但「逻辑」上还是当做一个机房来用</p>
<p>6、两地三中心是在同城双活的基础上，额外部署一个异地机房做「灾备」，用来抵御「城市」级别的灾害，但启用灾备机房需要时间</p>
<p>7、异地双活才是抵御「城市」级别灾害的更好方案，两个机房同时提供服务，故障随时可切换，可用性高。但实现也最复杂，理解了异地双活，才能彻底理解异地多活</p>
<p>8、异地多活是在异地双活的基础上，任意扩展多个机房，不仅又提高了可用性，还能应对更大规模的流量的压力，扩展性最强，是实现高可用的最终方案</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇文章我从「宏观」层面，向你介绍了异地多活架构的「核心」思路，整篇文章的信息量还是很大的，如果不太好理解，我建议你多读几遍。</p>
<p>因为篇幅限制，很多细节我并没有展开来讲。这篇文章更像是讲异地多活的架构之「道」，而真正实施的「术」，要考虑的点其实也非常繁多，因为它需要开发强大的「基础设施」才可以完成实施。</p>
<p>不仅如此，要想真正实现异地多活，还需要遵循一些原则，例如业务梳理、业务分级、数据分类、数据最终一致性保障、机房切换一致性保障、异常处理等等。同时，相关的运维设施、监控体系也要能跟得上才行。</p>
<p>宏观上需要考虑业务（微服务部署、依赖、拆分、SDK、Web 框架）、基础设施（服务发现、流量调度、持续集成、同步中间件、自研存储），微观上要开发各种中间件，还要关注中间件的高性能、高可用、容错能力，其复杂度之高，只有亲身参与过之后才知道。</p>
<p>我曾经有幸参与过，存储层同步中间件的设计与开发，实现过「跨机房」同步 MySQL、Redis、MongoDB 的中间件，踩过的坑也非常多。当然，这些中间件的设计思路也非常有意思，有时间单独分享一下这些中间件的设计思路。</p>
<p>值得提醒你的是，只有真正理解了「异地双活」，才能彻底理解「异地多活」。在我看来，从同城双活演变为异地双活的过程，是最为复杂的，最核心的东西包括，<strong>业务单元化划分、存储层数据双向同步、最上层的分片逻辑</strong>，这些是实现异地多活的重中之重。</p>
<blockquote>
<p>在写这篇文章时，我又仔细阅读了阿里、饿了么、微博等公司，关于异地多活架构设计的相关资料，如果你想更深入地学习异地多活架构，可以在我的公众号后台回复「异地多活」获取。</p>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div>如果此文章能给您带来小小的工作效率提升，不妨小额赞助我一下，以鼓励我写出更好的文章！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/wx-qr-code.png" alt="Kaito 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Kaito
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://kaito-kidd.com/2021/10/15/what-is-the-multi-site-high-availability-design/" title="搞懂异地多活，看这篇就够了">http://kaito-kidd.com/2021/10/15/what-is-the-multi-site-high-availability-design/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章未经允许禁止转载！如需转载，请联系作者或关注微信公众号「水滴与银弹」申请授权。
  </li>
</ul>
</div>

        

  <div class="followme">
    <div class="social-list">

        <div class="social-item">
            <img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/qr_block.jpg" width="200" height="200">
            <center><strong>关注「水滴与银弹」公众号，看更多硬核技术文章。</strong></center>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag"><i class="fa fa-tag"></i> 高可用</a>
              <a href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 架构</a>
              <a href="/tags/%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB/" rel="tag"><i class="fa fa-tag"></i> 异地多活</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/05/movie-a-great-dream-machine/" rel="prev" title="电影，绝佳的造梦机器">
      <i class="fa fa-chevron-left"></i> 电影，绝佳的造梦机器
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/19/macbook-pro-m1pro-m1max/" rel="next" title="新款MacBook Pro高燃发布，2款高端芯片吊打M1">
      新款MacBook Pro高燃发布，2款高端芯片吊打M1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#01-系统可用性"><span class="nav-number">1.</span> <span class="nav-text">01 系统可用性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#02-单机架构"><span class="nav-number">2.</span> <span class="nav-text">02 单机架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#03-主从副本"><span class="nav-number">3.</span> <span class="nav-text">03 主从副本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#04-风险不可控"><span class="nav-number">4.</span> <span class="nav-text">04 风险不可控</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#05-同城灾备"><span class="nav-number">5.</span> <span class="nav-text">05 同城灾备</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#06-同城双活"><span class="nav-number">6.</span> <span class="nav-text">06 同城双活</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#07-两地三中心"><span class="nav-number">7.</span> <span class="nav-text">07 两地三中心</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#08-伪异地双活"><span class="nav-number">8.</span> <span class="nav-text">08 伪异地双活</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#09-真正的异地双活"><span class="nav-number">9.</span> <span class="nav-text">09 真正的异地双活</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-如何实施异地双活"><span class="nav-number">10.</span> <span class="nav-text">10 如何实施异地双活</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-异地多活"><span class="nav-number">11.</span> <span class="nav-text">11 异地多活</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">12.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">13.</span> <span class="nav-text">后记</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kaito"
      src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/15584.jpg">
  <p class="site-author-name" itemprop="name">Kaito</p>
  <div class="site-description" itemprop="description">坐标北京，9年+工作经验，做过UGC高并发后端服务研发，目前从事基础架构&云原生方向，涉及领域包括：Redis、中间件、基础架构、异地多活、K8s、云原生。追求技术，关注互联网动态。工具控、电影迷！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaito</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">435k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">12:05</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'hk0NEMkBFXhLXkpBOAkmNgK1-gzGzoHsz',
      appKey     : 'ex6vIdRYs7yCbA7x21gaNCeu',
      placeholder: "欢迎和我一起交流！(支持markdown语法)",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
